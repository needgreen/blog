# 원시값과 객체의 비교

JavaScript의 데이터 타입은 **원시 타입**과 **객체 타입**으로 구분된다. 두 가지 방식의 차이를 이해해보자.

### 1. 용어 정리

- **변수(variable)**: 값을 담는 메모리 공간에 붙인 이름.
- **값(value)**: 변수에 저장된 데이터
- **불변성(immutability)**: **값 자체**를 바꿀 수 없음(원시값)
- **재할당(reassignment)**: 변수에 **새 값**을 넣는 것.
- **참조값(reference)**: 객체가 저장된 메모리 위치를 가리키는 값.

### 2. 원시값(Primitive Value)

- 원시 타입 : number, string, boolean, undefined, null, symbol, bigint
- 원시 타입의 값은 **변경이 불가능한 값**이다. 원시값을 가진 변수에 새 값을 재할당하면 새로운 메모리에 새로운 값을 저장하고 변수는 새로운 값을 가리킨다.
- 특징 : 원시 값은 불변의 값이므로 데이터의 신뢰성을 보장한다.

  ```jsx
  // 숫자 예시
  let score = 80; // 메모리 A에 80
  score = 90; // 메모리 B에 90 생성, 변수는 B를 가리킴
  ```

  ```jsx
  // 문자열 예시
  let str = 'string';
  str[0] = 'S'; // 인덱스로 접근 할 수 있지만 변경 불가함
  str = 'String'; // 새 문자열로 재할당
  ```

- 값에 의한 전달 : 다른 변수에 할당하면 값이 복사되며 서로 독립 저장된다.

### 3. 객체(Object)

- 객체는 프로퍼티의 개수가 정해져 있지 않은 **변경 가능한 값(가변)**이다.
- 변수는 객체 그 자체를 담지 않고 객체가 있는 참조값(reference value)을 담는다.
- 같은 객체를 가리키는 여러 변수는 같은 참조값을 공유하므로, 한쪽에서 객체를 변경하면 다른 쪽도 영향을 받는다.
- 재할당 없이 프로퍼티 추가, 변경, 삭제 등 수정이 가능하다.
  - `const`로 선언한 경우
    ```jsx
    const person = { name: 'Lee' };
    // person에는 객체의 참조값이 저장됨
    person.name = 'Kim';
    // person에 저장된 객체의 프로퍼티 값 변경(객체 내부 수정)
    console.log(person); // { name: 'Kim' }

    person = { name: 'Park' }; // ❌ TypeError
    // person에 새로운 객체 재할당 시도
    // const로 선언되었으므로 재할당 불가
    ```
  - `let`으로 선언한 경우
    ```jsx
    let person = { name: 'Lee' };

    // 객체 프로퍼티 변경
    person.name = 'Kim';
    console.log(person); // { name: 'Kim' }

    // 변수에 새 객체 재할당
    person = { name: 'Park' };
    console.log(person); // { name: 'Park' }
    ```
- 참조에 의한 전달(공유) → 객체 변수를 다른 변수에 할당하면 참조값(메모리 주소)이 복사되어 같은 객체를 가리킨다.

### 4. 객체의 얕은 복사 vs 깊은 복사

- 얕은 복사 : 1단계만 복사하고 중첩 객체는 주소를 공유한다.
  ```jsx
  const o = { x: { y: 1 } };
  const c1 = { ...o };
  c1.x.y = 2;
  console.log(o.x.y); // 2 (같은 x를 공유)
  ```
- 깊은 복사 : 중첩된 객체까지 모두 새로운 값으로 복사한다.

### 5. 원시값과 객체 비교

| 구분           | 원시값             | 객체                     |
| -------------- | ------------------ | ------------------------ |
| 변경 가능 여부 | ❌ 값 자체 불변    | ⭕ 내부 변경 가능        |
| 변수 할당      | 값 자체            | 참조값(주소)             |
| 재할당         | **값 복사** → 독립 | **참조값 복사** → 공유   |
| 변경 효과      | 독립적             | 서로 영향 가능           |
| 복사 난이도    | 의미 없음          | 얕은/깊은 복사 고려 필요 |

### 6. 연습 문제

**문제 1 .** 아래 코드를 확인하고 결과 값을 맞춰 보세요.

```jsx
const a = 'hi';
const b = a;
a[0] = 'H';
console.log(a, b); // ?
```

- 정답보기
  `hi hi`
  → 문자열은 원시값이므로 불변함. 인덱스를 통해 수정하려고 해도 변경이 불가하며 무시됨.

**문제 2.** 아래 코드를 확인하고 결과 값을 맞춰 보세요.

```jsx
const p1 = { n: 1 };
const p2 = p1;
p1.n = 2;
console.log(p1.n, p2.n); //  ?
```

- 정답보기
  `2 2`
  → p1에는 객체의 참조값(메모리 주소)이 저장됨.
        p2에도 p1과 같은 참조값이 복사되며 p1과 p2는 같은 객체를 가리킴.

        `p1.n=2;` p1이 가리키는 객체의 n 프로퍼티를 2로 변경

         P2도 같은 객체를 가리키므로 p2.n도 2가 됨.

**문제 3.** 아래 코드를 확인하고 결과 값을 맞춰 보세요.

```jsx
const o1 = { x: { y: 1 } };
const o2 = { ...o1 };
o2.x.y = 9;
console.log(o1.x.y); // ?
```

- 정답보기
  `9`
  → 스프레드 연산자(…)는 얕은 복사를 수행함.
  `o2`는 새로운 객체로 생성, 1단계만 복사됨.
  중첩된 객체 `{ y: 1 }`은 복사되지 않고 참조값만 복사됨.
  `o1.x`와 `o2.x`는 같은 객체를 가리킴.

### 📝 마무리

자바스크립트에서 변수와 값의 구분은 중요하다.

원시값은 불변이라 값을 변경할 수 없고 변경하려면 변수에 재할당이 일어난다.

객체는 변경 가능한 값으로 같은 객체를 가리키는 변수가 여러 개라면 한 쪽 변경이 다른 쪽에도 영향을 준다. 따라서 **변수 할당 시 원시값은 값 자체가 복사되고, 객체는 참조값이 복사된다.**

- const는 재할당만 막을 뿐 객체 내부의 변경은 가능하다.
